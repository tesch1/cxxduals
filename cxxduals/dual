// -*-c++-*-
//
// The MIT License (MIT)
// 
// Copyright (c) 2006 Jeffrey A. Fike
// Copyright (C) 2015 Michael Tesch tesch1 a gmail com
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//
// Version 0.0.2
//
// Thanks to Jeff Fike for publishing the dual original code upon
// which this file is based.
//
// The cxxdual package is available on github, bug reports and feature
// additions are welcome.
//
//  Docs:   http://tesch1.github.io/cxxduals
//  Source: https://github.com/tesch1/cxxduals
//
// #ifndef CXXDUALS_NO_COMPLEX
//
#ifndef LIB_CXXDUALS
#define LIB_CXXDUALS 1

#include <cmath>
#include <ctgmath>
#include <sstream>
#include <limits>
#include <valarray>
#include <type_traits>
#include <initializer_list>
#include <random>
#include <functional>

#ifndef CXXDUALS_NO_COMPLEX
#include <complex>
#endif

// check if constexpr exists
#if __cplusplus >= 201103L || defined(_WIN32)
#define CXXDUALS_CONSTEXPR constexpr
#else
#define CXXDUALS_CONSTEXPR const
#endif

#ifdef __CUDACC__
// /////////////// Stuff missing in CUDA ///////////////////
#define DUAL_DEVICE_FUNC __host__ __device__
#define DUAL_STD_MATH(FUNC) using ::FUNC

#include <float.h>
#ifndef NPP_MIN_8U
#include <nppdefs.h>
#undef NV_NPPIDEFS_H
#endif
#include <math_constants.h>

template <typename T> struct numeric_limits;

template <> struct numeric_limits<float>
{
  __device__ __forceinline__ static float quiet_NaN() { return CUDART_NAN_F; };
  __device__ __forceinline__ static float infinity() { return CUDART_INF_F; };
  __device__ __forceinline__ static float epsilon() { return FLT_EPSILON; };
  __device__ __forceinline__ static float min() { return NPP_MINABS_32F; };
  __device__ __forceinline__ static float max() { return NPP_MAXABS_32F; };
};

template <> struct numeric_limits<double>
{
  __device__ __forceinline__ static double quiet_NaN() { return CUDART_NAN; };
  __device__ __forceinline__ static double infinity() { return CUDART_INF; };
  __device__ __forceinline__ static double epsilon() { return DBL_EPSILON; };
  __device__ __forceinline__ static double min() { return NPP_MINABS_64F; };
  __device__ __forceinline__ static double max() { return NPP_MAXABS_64F; };
};

template <> struct numeric_limits<short>
{
  __device__ __forceinline__ static short max() { return SHRT_MAX; };
};

template <typename Tp>
bool isnormal(const Tp & x)
{
  // maybe not exactly right?
  return !(x==0.0 || isnan(x) || isinf(x) || isfinite(x));
}

#else
// /////////////// Not CUDA ///////////////////

#define DUAL_DEVICE_FUNC
#define DUAL_STD_MATH(FUNC) using std::FUNC
#endif
// /////////////// End CUDA ///////////////////

/*!
 * dual-numbers implementation for calculation of differentials
 */
namespace cxxduals {

// forward declaration
template <typename Tp, unsigned Ne> class dual;

// useful typedefs
#ifndef CXXDUALS_NO_TYPEDEFS
typedef dual<float, 1> dualf;
typedef dual<double, 1> duald;
typedef dual<long double, 1> dualld;
#ifndef CXXDUALS_NO_COMPLEX
typedef dual<std::complex<float>, 1> dualcf;
typedef dual<std::complex<double>, 1> dualcd;
typedef dual<std::complex<long double>, 1> dualcld;
#endif // CXXDUALS_NO_COMPLEX

#if __cplusplus >= 201103L || defined(_WIN32)
template <class Tp, unsigned Ne = 1> using hyperdual = dual<dual<Tp,Ne>,Ne>;
typedef hyperdual<float> hyperdualf;
typedef hyperdual<double> hyperduald;
typedef hyperdual<long double> hyperdualld;
#ifndef CXXDUALS_NO_COMPLEX
typedef hyperdual<std::complex<float> > hyperdualcf;
typedef hyperdual<std::complex<double> > hyperdualcd;
typedef hyperdual<std::complex<long double> > hyperdualcld;
#endif // CXXDUALS_NO_COMPLEX
#endif // __cplusplus >= 201103L
#endif // CXXDUALS_NO_TYPEDEFS

} // cxxduals

//! muckin about in std:: to enable std::numeric_limits<> is allowed
//! by C++03 17.4.3.1/1, and C++11 18.3.2.3/1
#ifndef CXXDUALS_NO_LIMITS
namespace std {
#if 1
template<typename Tp, unsigned Ne>
struct numeric_limits<cxxduals::dual<Tp,Ne> > : public numeric_limits<Tp> {
  typedef cxxduals::dual<Tp,Ne> T;
  static CXXDUALS_CONSTEXPR bool is_specialized = true;
  static CXXDUALS_CONSTEXPR T min()           { return T(numeric_limits<Tp>::min()); }
  static CXXDUALS_CONSTEXPR T max()           { return T(numeric_limits<Tp>::max()); }
  static CXXDUALS_CONSTEXPR T epsilon()       { return T(numeric_limits<Tp>::epsilon()); }
  static CXXDUALS_CONSTEXPR T round_error()   { return T(numeric_limits<Tp>::round_error()); }
  static CXXDUALS_CONSTEXPR T infinity()      { return T(numeric_limits<Tp>::infinity()); }
  static CXXDUALS_CONSTEXPR T quiet_NaN()     { return T(numeric_limits<Tp>::quiet_NaN()); }
  static CXXDUALS_CONSTEXPR T signaling_NaN() { return T(numeric_limits<Tp>::signaling_NaN()); }
  static CXXDUALS_CONSTEXPR T denorm_min()    { return T(numeric_limits<Tp>::denorm_min()); }
};
#endif
// TODO: cv-specializations (C++11 18.3.2.3/2)

//! common_type specializations for dual
template <typename Tp, typename _Up, unsigned Ne>
struct common_type<cxxduals::dual<Tp,Ne>, cxxduals::dual<_Up,Ne> > {
  typedef cxxduals::dual<typename std::common_type<Tp, _Up>::type, Ne> type;
};
} // std
#endif // CXXDUALS_NO_LIMITS

namespace cxxduals {

#ifndef CXXDUALS_NO_COMPLEX
/// check if something is complex
template <class T> struct is_complex : std::false_type {};
template <class T> struct is_complex<std::complex<T> > : std::true_type {};
#endif

/// check if something is dual
template <typename... Ts> struct is_dual : std::false_type {};
template <typename... Ts> struct is_dual<dual<Ts...> > : std::true_type {};

namespace internal {
/// Useful type trait extraction for templpated types, helper for Tp
/// being a basic type (float, double, ...).  Used by dual_traits<>.
template <typename Tp>
struct dual_traits_basic {
  typedef Tp scalar_type;              ///< The intrinsic scalar type (double, float,...)
  typedef Tp value_type;               ///< The type of part(), rpart() and epart()
  typedef Tp basic_value_type;         ///< Used to differentiate complex/dual types
  static const int depth = 0;           ///< Depth of nested duals, a
                                        ///  dual<double> is 0, a
                                        ///  dual<dual<double>> is 1
  static const int num_elem = 1;        ///< How many basic_value_type parts the dual has (2^depth)
  typedef std::false_type is_nested;    ///< Is this a nested dual?
  typedef std::false_type is_dual;      ///< Is Tp even a dual?
};
} // internal::

/// Get trait information about a dual number (see
/// internal::dual_traits_basic for traits)
template <typename Ts> struct dual_traits;

/// Specialization of dual_traits for int
template <> struct dual_traits<int> : public internal::dual_traits_basic<float> {};

/// Specialization of dual_traits for float
template <> struct dual_traits<float> : public internal::dual_traits_basic<float> {};

/// Specialization of dual_traits for double
template <> struct dual_traits<double> : public internal::dual_traits_basic<double> {};

/// Specialization of dual_traits for long double
template <> struct dual_traits<long double> : public internal::dual_traits_basic<long double> {};

#ifndef CXXDUALS_NO_COMPLEX
/// Complex dual traits
template <typename Tp>
struct dual_traits<std::complex<Tp> > : public dual_traits<Tp> {
  typedef typename dual_traits<Tp>::scalar_type scalar_type;
  typedef Tp value_type;
  typedef std::complex<Tp> basic_value_type;
};
#endif // CXXDUALS_NO_COMPLEX

/// Get traits of duals
template <typename Tp, unsigned Ne>
struct dual_traits<dual<Tp,Ne> > {
  typedef typename dual_traits<Tp>::scalar_type scalar_type;
  typedef Tp value_type;
  typedef typename dual_traits<Tp>::basic_value_type basic_value_type;
  static const int depth = dual_traits<Tp>::depth + 1;
  static const int num_elem = dual_traits<Tp>::num_elem * 2;
  typedef std::true_type is_dual;
  typedef typename dual_traits<Tp>::is_dual is_nested;
};

namespace internal {
/// filter to exclude complex from templated arguments
template <typename Tp> struct nocx_filter;
template <> struct nocx_filter<int> { typedef int test; };
template <> struct nocx_filter<float> { typedef int test; };
template <> struct nocx_filter<double> { typedef int test; };
template <> struct nocx_filter<long double> { typedef int test; };

/// Filter to enable tempated arg if a condition B is met
template <bool B, class T = void >
using enable_if_t = typename std::enable_if<B,T>::type;

/// Filter to only allow basic types in templated arg type
template <typename Tp> struct arg_filter;
template <> struct arg_filter<int> { typedef int test; };
template <> struct arg_filter<float> { typedef int test; };
template <> struct arg_filter<double> { typedef int test; };
template <> struct arg_filter<long double> { typedef int test; };

template <typename Tp> struct is_arithmetic : public std::is_arithmetic<Tp> {
  typedef typename std::is_arithmetic<Tp>::type type;
};

#ifndef CXXDUALS_NO_COMPLEX
#if 1
template <> struct arg_filter<std::complex<float> > { typedef int test; };
template <> struct arg_filter<std::complex<double> > { typedef int test; };
template <> struct arg_filter<std::complex<long double> > { typedef int test; };
#endif // 1
template <typename Tp> struct is_arithmetic<std::complex<Tp> > : public std::integral_constant<bool, true> {};
#endif // CXXDUALS_NO_COMPLEX

} // internal::

/// dual number class
template <typename Tp, unsigned Ne = 1>
class dual {
  static_assert(Ne >= 1, "dual numbers must have at least one epsilon part");
private:
  Tp _f0;
  //std::array<Tp,Ne> _f1;
  std::valarray<Tp> _f1;
  typedef dual<Tp, Ne> dual_type;

  /// Apply a function to all elements of _f1 and return the result
  template <typename At>
  std::valarray<At> f1_apply(std::function<At(Tp const &)> func) const {
    std::valarray<At> res(Ne);
    for (unsigned ii = 0; ii < Ne; ii++)
      res[ii] = func(_f1[ii]);
    return res;
  }
  template <typename At>
  std::valarray<At> f1_cast() const {
    return this->f1_apply<At>([](Tp x) -> At { return x; });
  }

public:

  /// Type of rpart() and epart()
  typedef Tp value_type;
  typedef typeof(_f1) Tp1;

  // 
  typedef typename dual_traits<Tp>::basic_value_type basic_value_type;
  typedef typename dual_traits<Tp>::scalar_type scalar_type;
  static const int nep = Ne;
  static const int depth = dual_traits<dual<Tp,Ne> >::depth;
  static const int num_elem = dual_traits<dual<Tp,Ne> >::num_elem;

  /// Constructor - no initialization
  DUAL_DEVICE_FUNC
  CXXDUALS_CONSTEXPR dual()
    : _f0(), _f1(Ne) { }

  /// Constructor - specify real part, zero dual part
  DUAL_DEVICE_FUNC
#if __cpp_constexpr >= 201304 // c++14
  CXXDUALS_CONSTEXPR
#endif
  dual(const Tp & f0)
    : _f0(f0), _f1((Tp)0, (size_t)Ne) {}

  /// Constructor - specify real and dual parts
  template <unsigned Nee = Ne,
            internal::enable_if_t<Nee == 1>* = nullptr>
  DUAL_DEVICE_FUNC
  CXXDUALS_CONSTEXPR dual(const Tp & f0, const Tp & f1)
    : _f0(f0), _f1{f1} { }

  /// Constructor - specify real and dual parts
  DUAL_DEVICE_FUNC
  CXXDUALS_CONSTEXPR dual(const Tp & f0, const Tp1 & f1)
    : _f0(f0), _f1(f1) { }

  /// Construct from lower dual<>
  template <typename _Up,
            internal::enable_if_t<dual_traits<dual<_Up>>::depth < depth>* = nullptr>
  DUAL_DEVICE_FUNC
#if __cpp_constexpr >= 201304
  CXXDUALS_CONSTEXPR
#endif
  dual(const _Up & f0)
    : _f0(Tp(f0)), _f1((Tp)0, (size_t)Ne) {}

  /// Construct from compatible parts
  template <typename _Up,
            internal::enable_if_t<dual_traits<dual<_Up,Ne> >::depth == depth>* = nullptr>
  DUAL_DEVICE_FUNC
  CXXDUALS_CONSTEXPR dual(const _Up & f0, const Tp1 & f1)
    : _f0(f0), _f1(f1) { }

  /// Construct from compatible parts, if Ne==1
  template <unsigned Nee = Ne,
            internal::enable_if_t<Nee == 1>* = nullptr,
            typename _Up,
            typename _Vp,
            internal::enable_if_t<dual_traits<_Up>::depth == depth-1>* = nullptr,
            internal::enable_if_t<dual_traits<_Vp>::depth == depth-1>* = nullptr>
  DUAL_DEVICE_FUNC
  CXXDUALS_CONSTEXPR dual(const _Up & f0, const _Vp & f1)
    : _f0(f0), _f1{f1} { }

#if __cplusplus >= 201103L || defined(_WIN32)
  /// List initializer, this is for allowing nested
  //  duals to have simpler initializers, ie for
  // dual<dual<double>> x{1,2,3,4}; // 1 + 2*e1 + 3*e2 + 4*e3
  DUAL_DEVICE_FUNC
  dual(std::initializer_list<basic_value_type> ll)
    : _f0(), _f1()
  {
#ifndef __CUDACC__
    if (ll.size() > num_elem)
      throw std::exception();
#endif
    int ii = 0;
    for (auto it = ll.begin(); it != ll.end(); it++, ii++)
      part(ii) = *it;
  }
#endif

  /// We're friends with all other duals (\todo ...of equal depth)
  template<typename _Up, unsigned Nf> friend class dual;

  /// Copy constructor from dual of diff type
  template<typename _Up,
           internal::enable_if_t<dual_traits<dual<_Up> >::depth == depth>* = nullptr>
  DUAL_DEVICE_FUNC
  dual(const dual<_Up, Ne> & rhs)
    : _f0(Tp(rhs._f0)) { _f1 = rhs.template f1_cast<Tp>(); }

  /// Real part
  DUAL_DEVICE_FUNC       Tp & rpart()       { return _f0; }
  DUAL_DEVICE_FUNC const Tp & rpart() const { return _f0; }

  /// Dual (epsilon) part
  DUAL_DEVICE_FUNC       Tp & epart(unsigned en = 0)       { return _f1[en]; }

  /// Dual (epsilon) part const
  DUAL_DEVICE_FUNC const Tp & epart(unsigned en = 0) const { return _f1[en]; }

  /// Dual (epsilon) parts
  DUAL_DEVICE_FUNC       Tp1 & eparts()       { return _f1; }

  /// Dual (epsilon) parts const
  DUAL_DEVICE_FUNC const Tp1 & eparts() const { return _f1; }

#if __cplusplus >= 201103L || defined(_WIN32)

private:
  /// Helper for `constexpr part(int) const`
  DUAL_DEVICE_FUNC
  constexpr basic_value_type
  private_part(int p, std::false_type) const {
    // p had better be either 0 or 1
    return p == 0 ? _f0 : _f1;
  }

  /// Helper for `constexpr part(int) const`
  DUAL_DEVICE_FUNC
  constexpr basic_value_type
  private_part(int p, std::true_type) const {
    return p < (num_elem / 2)
               ? _f0.part(p)
               : _f1.part(p - (dual_traits<dual<Tp,Ne> >::num_elem / 2));
  }

public:
  /// Part-wise access, for nested duals
  DUAL_DEVICE_FUNC
  constexpr basic_value_type
  part(int p) const {
    return private_part(p, typename dual_traits<Tp>::is_dual());
  }

#else // old c++

  /// Real part
  DUAL_DEVICE_FUNC
  const Tp &
  rpart() const { return _f0; }

  /// Dual (epsilon) part
  DUAL_DEVICE_FUNC
  const Tp1 &
  eparts() const { return _f1; }

#endif

private:
  /// Helper for `part(int)`
  DUAL_DEVICE_FUNC
  basic_value_type &
  private_part(int p, std::false_type) {
    return p == 0 ? _f0 : _f1;
  }

  /// Helper for `part(int)`
  DUAL_DEVICE_FUNC
  basic_value_type &
  private_part(int p, std::true_type) {
    return p < (num_elem / 2)
               ? _f0.part(p)
               : _f1.part(p - (dual_traits<dual<Tp,Ne> >::num_elem / 2));
  }

public:

  /// Part-wise access
  DUAL_DEVICE_FUNC
  basic_value_type &
  part(int p) {
    return private_part(p, typename dual_traits<Tp>::is_dual());
  }

private:
  /// Helper for part-wise assignment
  DUAL_DEVICE_FUNC
  void
  private_part(int p, const basic_value_type & v, std::false_type) {
    if (p == 0)
      _f0 = v;
    else
      _f1 = v;
  }

  /// Helper for part-wise assignment
  DUAL_DEVICE_FUNC
  void
  private_part(int p, const basic_value_type & v, std::true_type) {
    if (p < (num_elem / 2))
      _f0.part(p, v);
    else
      _f1.part(p - (dual_traits<dual<Tp,Ne> >::num_elem / 2), v);
  }

public:

  /// Set a single part value
  DUAL_DEVICE_FUNC
  void
  part(int p, const basic_value_type & v) {
    private_part(p, v, typename dual_traits<Tp>::is_dual());
  }

  /// Assignment
  template <typename _Up,
            internal::enable_if_t<dual_traits<_Up>::depth < depth>* = nullptr>
  DUAL_DEVICE_FUNC
  dual<Tp,Ne> &
  operator=(const _Up & f0) {
    _f0 = f0;
    _f1 = Tp(0);
    return *this;
  }

  /// Assignment from another dual<> \todo restrict to depth<_Up> == depth<Tp>
  template<typename _Up,
           internal::enable_if_t<dual_traits<dual<_Up> >::depth == depth>* = nullptr>
  DUAL_DEVICE_FUNC
  dual<Tp,Ne> &
  operator=(const dual<_Up,Ne> & rhs) {
    _f0 = rhs._f0;
    _f1 = rhs.template f1_apply<Tp>([](_Up x) -> Tp { return Tp(x); });
    //std::copy(rhs._f1.begin(), rhs._f1.end(), _f1.begin());
    return *this;
  }

  // Operations

  /// explicit cast to Scalar type -- same as rpart()
  DUAL_DEVICE_FUNC
  explicit operator Tp () const { return rpart(); }

  /// unitary plus - passthrough
  DUAL_DEVICE_FUNC
  dual<Tp,Ne>
  operator+() const { return *this; }

  /// unitary negation
  DUAL_DEVICE_FUNC
  dual<Tp,Ne>
  operator-() const
  {
    return dual<Tp,Ne>(-_f0, -_f1);
  }

  /// addition
  /**
   * \f[
   * (a + b \epsilon) + c
   * \f]
   */
  DUAL_DEVICE_FUNC
  dual<Tp,Ne> &
  operator+=(const Tp & rhs)
  {
    _f0 += rhs;
    return *this;
  }

  /**
   * \f[
   * (a + b \epsilon) + (c + d \epsilon)
   * \f]
   */
  template<typename _Up,
           internal::enable_if_t<dual_traits<dual<_Up> >::depth == depth>* = nullptr>
  DUAL_DEVICE_FUNC
  dual<Tp,Ne> &
  operator+=(const dual<_Up,Ne> & rhs)
  {
    _f0 += rhs.rpart();
    for (unsigned ii = 0; ii < Ne; ii++)
      _f1[ii] += rhs.epart(ii);
    return *this;
  }

  /// subtraction
  /**
   * \f[
   * (a + b \epsilon) - c
   * \f]
   */
  DUAL_DEVICE_FUNC
  dual<Tp,Ne> &
  operator-=(const Tp & rhs)
  {
    _f0 -= rhs;
    return *this;
  }

  /**
   * \f[
   * (a + b \epsilon) - (c + d \epsilon)
   * \f]
   */
  template<typename _Up,
           internal::enable_if_t<dual_traits<dual<_Up> >::depth == depth>* = nullptr>
  DUAL_DEVICE_FUNC
  dual<Tp,Ne> &
  operator-=(const dual<_Up,Ne> & rhs)
  {
    _f0 -= rhs.rpart();
    for (unsigned ii = 0; ii < Ne; ii++)
      _f1[ii] -= rhs.epart(ii);
    return *this;
  }

  /// multiplication
  /**
   * \f[
   * (a + b \epsilon) * c
   * \f]
   */
  DUAL_DEVICE_FUNC
  dual<Tp,Ne> &
  operator*=(const Tp & rhs)
  {
    _f0 *= rhs;
    _f1 *= rhs;
    return *this;
  }

  /// multiplication
#ifndef CXXDUALS_NO_COMPLEX
  /**
   * Scalar multiplication when the value_type is complex
   * \f[
   * (a + (b+e*i) \epsilon) * c = (ac + (b+e*i)c \epsilon )
   * \f]
   */
  template<typename _Up>
  DUAL_DEVICE_FUNC
  dual<Tp,Ne> &
  operator*=(const typename std::complex<_Up> & rhs)
  {
    _f0 *= rhs;
    _f1 *= rhs;
    return *this;
  }
#endif // CXXDUALS_NO_COMPLEX

  /**
   * \f[
   * (a + b \epsilon) * (c + d \epsilon)
   * \f]
   *
   * \f[
   * 
   * \begin{pmatrix}
   * a & b \\
   * 0 & a \\
   * \end{pmatrix}
   *
   * \begin{pmatrix}
   * c & d \\
   * 0 & c \\
   * \end{pmatrix}
   * =
   * \begin{pmatrix}
   * ac & ad+bc \\
   * 0  & ac    \\
   * \end{pmatrix}
   * 
   * \f]
   */
  template<typename _Up,
           internal::enable_if_t<dual_traits<dual<_Up> >::depth == depth>* = nullptr>
  DUAL_DEVICE_FUNC
  dual<Tp,Ne> &
  operator*=(const dual<_Up,Ne> & rhs)
  {
    Tp aa, cc;
    Tp1 bb, dd;
    aa = _f0;
    bb = _f1;
    cc = rhs.rpart();
    dd = rhs.epart();
    _f0 = aa * cc;
    _f1 = aa * dd + bb * cc;
    return *this;
  }

  /// division
  /**
   * \f[
   * (a + b \epsilon) / c
   * \f]
   */
  DUAL_DEVICE_FUNC
  dual<Tp,Ne> &
  operator/=(const Tp & rhs)
  {
    _f0 /= rhs;
    _f1 /= rhs;
    return *this;
  }

  /**
   * \f[
   * (a + b \epsilon) / (c + d \epsilon)
   * \f]
   *
   * \f[
   * 
   * \begin{pmatrix}
   * a & b \\
   * 0 & a \\
   * \end{pmatrix}
   *
   * \begin{pmatrix}
   * c & d \\
   * 0 & c \\
   * \end{pmatrix} ^ {-1}
   * =
   * \begin{pmatrix}
   * a & b \\
   * 0 & a \\
   * \end{pmatrix}
   * \frac{1}{c^2}
   * \begin{pmatrix}
   * c  & -d   \\
   * 0  &  c   \\
   * \end{pmatrix}
   * =
   * \frac{1}{c^2}
   * \begin{pmatrix}
   * ac & -ad + bc  \\
   * 0  & ac        \\
   * \end{pmatrix}
   * =
   * \begin{pmatrix}
   * a/c & \frac{bc - ad}{c^2}  \\
   * 0   & a/c                  \\
   * \end{pmatrix} \\
   *
   * = (a/c + \frac{bc - ad}{c^2} \epsilon)
   *
   * \f]

   */
  template<typename _Up,
           internal::enable_if_t<dual_traits<dual<_Up> >::depth == depth>* = nullptr>
  DUAL_DEVICE_FUNC
  dual<Tp,Ne> &
  operator/=(const dual<_Up,Ne> & rhs)
  {
    for (unsigned ii = 0; ii < Ne; ii++)
      _f1[ii] = (_f1[ii] * rhs.rpart() - _f0 * rhs.epart(ii)) / (rhs.rpart() * rhs.rpart());
    _f0 = _f0 / rhs.rpart();
    return *this;
  }

};

template <typename Tp, unsigned Ne>
inline dual<Tp,Ne>
copysign(dual<Tp,Ne> x, dual<Tp,Ne> y)
{
  x.rpart() = ::copysign(x.rpart(), y.rpart());
  return x;
}

/// Value extraction
//@{
/**
 * \f[
 * rpart(a + b \epsilon) = a
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
inline Tp
rpart(const dual<Tp,Ne> & d)
{
  return d.rpart();
}

/**
 * \f[
 * rpart(a) = a
 * \f]
 */
template <typename Tp,
          typename Tpf = typename internal::arg_filter<Tp>::test>
DUAL_DEVICE_FUNC
inline Tp
rpart(const Tp & d)
{
  return d;
}

#ifndef CXXDUALS_NO_COMPLEX
/**
 * \f[
 * rpart((a + b \epsilon) + i*(c + d \epsilon)) = (a + c*i)
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
inline std::complex<Tp>
rpart(const std::complex<dual<Tp,Ne> > & d)
{
  return std::complex<Tp>(d.real().rpart(), d.imag().rpart());
}
#endif

/**
 * \f[
 * epart(a + b \epsilon) = b
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
inline Tp epart(const dual<Tp,Ne> & d, unsigned en = 0)
{
  return d.epart(en);
}

/**
 * \f[
 * epart(a) = 0
 * \f]
 */
template <typename Tp,
          internal::enable_if_t<!is_dual<Tp>::value >* = nullptr>
DUAL_DEVICE_FUNC
inline Tp
epart(const Tp & d)
{
  return Tp(0);
}

//@}

/**
 * Random number in [a, b) - wrapper around std::default_random_engine
 * \f[
 * 
 * \f]
 */
template <typename Tp,
          typename Tpf = typename internal::nocx_filter<Tp>::test>
DUAL_DEVICE_FUNC
void rand(Tp & d, Tp a = 0, Tp b = 1)
{
  static std::default_random_engine generator;
  std::uniform_real_distribution<Tp> distribution(a, b);
  d = distribution(generator);
}

#ifndef CXXDUALS_NO_COMPLEX
/**
 * Random complex number
 * \f[
 * 
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
void rand(std::complex<Tp> & d,
          typename dual_traits<std::complex<Tp> >::scalar_type a = 0,
          typename dual_traits<std::complex<Tp> >::scalar_type b = 1)
{
  Tp x;
  rand(x, a, b);
  d.real(x);
  rand(x, a, b);
  d.imag(x);
}
#endif

/**
 * Random dual number with parts in [a, b)
 * \f[
 * 
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
void rand(dual<Tp,Ne> & d,
          typename dual_traits<dual<Tp,Ne> >::scalar_type a = 0,
          typename dual_traits<dual<Tp,Ne> >::scalar_type b = 1)
{
  typename dual_traits<dual<Tp,Ne> >::scalar_type x;
  for (int ii = 0; ii < dual_traits<dual<Tp,Ne> >::num_elem; ii++) {
    rand(x, a, b);
    d.part(ii, x);
  }
}

/**
 * Random dual number (used by Eigen::Random())
 * \f[
 * 
 * \f]
 */
template <typename Tp,
          internal::enable_if_t<is_dual<Tp>::value>* = nullptr>
DUAL_DEVICE_FUNC
Tp
random(typename dual_traits<Tp>::scalar_type a = 0,
       typename dual_traits<Tp>::scalar_type b = 1)
{
  Tp d;
  rand(d, a, b);
  return d;
}

// Trick to allow type promotion below
template <typename T>
struct identity_t { typedef T type; };

// basic ops
#define DUALH_DEFINE_BASIC_OP_TEMPLATES(OP)                             \
  template <typename Tp, typename _Up, unsigned Ne>                     \
  DUAL_DEVICE_FUNC                                                      \
  inline typename std::common_type<dual<Tp,Ne>, dual<_Up,Ne> >::type    \
  operator OP (const dual<Tp,Ne> & lhs, const dual<_Up,Ne> & rhs)       \
  {                                                                     \
    typename std::common_type<dual<Tp,Ne>, dual<_Up,Ne> >::type d = lhs; \
    d OP##= rhs;                                                        \
    return d;                                                           \
  }                                                                     \
  template <typename Tp, unsigned Ne>                                   \
  DUAL_DEVICE_FUNC                                                      \
  inline dual<Tp,Ne>                                                    \
  operator OP (const dual<Tp,Ne> & lhs, const typename identity_t<Tp>::type & rhs) \
  {                                                                     \
    dual<Tp,Ne> d = lhs;                                                \
    d OP##= rhs;                                                        \
    return d;                                                           \
  }                                                                     \
  template <typename Tp, unsigned Ne>                                   \
  DUAL_DEVICE_FUNC                                                      \
  inline dual<Tp,Ne>                                                    \
  operator OP (const typename identity_t<Tp>::type & lhs, const dual<Tp,Ne> & rhs) \
  {                                                                     \
    dual<Tp,Ne> d = lhs;                                                \
    d OP##= rhs;                                                        \
    return d;                                                           \
  }                                                                     \
  template <typename Tp, unsigned Ne>                                   \
  DUAL_DEVICE_FUNC                                                      \
  inline dual<Tp,Ne>                                                    \
  operator OP (const dual<Tp,Ne> & lhs, const typename Tp::value_type & rhs) \
  {                                                                     \
    dual<Tp,Ne> d = lhs;                                                \
    d OP##= rhs;                                                        \
    return d;                                                           \
  }                                                                     \
  template <typename Tp, unsigned Ne>                                   \
  DUAL_DEVICE_FUNC                                                      \
  inline dual<Tp,Ne>                                                    \
  operator OP (const typename Tp::value_type & lhs, const dual<Tp,Ne> & rhs) \
  {                                                                     \
    dual<Tp,Ne> d(lhs);                                                 \
    d OP##= rhs;                                                        \
    return d;                                                           \
  }

#ifndef CXXDUALS_NO_COMPLEX
#define DUALH_DEFINE_BASIC_OP_TEMPLATES_CX(OP)                          \
  template <typename Tp, unsigned Ne>                                   \
  DUAL_DEVICE_FUNC                                                      \
  inline std::complex<dual<Tp,Ne>>                                      \
  operator OP (const std::complex<dual<Tp,Ne>> & lhs, const std::complex<Tp> & rhs) \
  {                                                                     \
    std::complex<dual<Tp,Ne>> d = lhs;                                  \
    d OP##= rhs;                                                        \
    return d;                                                           \
  }                                                                     \
  template <typename Tp, unsigned Ne>                                   \
  DUAL_DEVICE_FUNC                                                      \
  inline std::complex<dual<Tp,Ne>>                                      \
  operator OP (const std::complex<Tp> & lhs, const std::complex<dual<Tp,Ne> > & rhs) \
  {                                                                     \
    std::complex<dual<Tp,Ne>> d = lhs;                                  \
    d OP##= rhs;                                                        \
    return d;                                                           \
  }                                                                     \
  template <typename Tp, unsigned Ne>                                   \
  DUAL_DEVICE_FUNC                                                      \
  inline std::complex<dual<Tp,Ne>>                                      \
  operator OP (const std::complex<dual<Tp,Ne>> & lhs, const Tp & rhs)   \
  {                                                                     \
    std::complex<dual<Tp,Ne>> d = lhs;                                  \
    d OP##= rhs;                                                        \
    return d;                                                           \
  }                                                                     \
  template <typename Tp, unsigned Ne>                                   \
  DUAL_DEVICE_FUNC                                                      \
  inline std::complex<dual<Tp,Ne>>                                      \
  operator OP (const Tp & lhs, const std::complex<dual<Tp,Ne> > & rhs)  \
  {                                                                     \
    std::complex<dual<Tp,Ne>> d = lhs;                                  \
    d OP##= rhs;                                                        \
    return d;                                                           \
  }
#else
#define DUALH_DEFINE_BASIC_OP_TEMPLATES_CX(OP)
#endif

//@{
///  Addition
DUALH_DEFINE_BASIC_OP_TEMPLATES(+)
DUALH_DEFINE_BASIC_OP_TEMPLATES_CX(+)
//@}

//@{
///  Subtraction
DUALH_DEFINE_BASIC_OP_TEMPLATES(-)
DUALH_DEFINE_BASIC_OP_TEMPLATES_CX(-)
//@}

//@{
///  Multiplication
DUALH_DEFINE_BASIC_OP_TEMPLATES(*)
DUALH_DEFINE_BASIC_OP_TEMPLATES_CX(*)
//@}

//@{
///  Division
DUALH_DEFINE_BASIC_OP_TEMPLATES(/)
DUALH_DEFINE_BASIC_OP_TEMPLATES_CX(/)
//@}

#undef DUALH_DEFINE_BASIC_OP_TEMPLATES

//
#if 0
// fix emacs auto formatting below this point for me
  ;
#endif

/**
 * \f[
 * (a + b \epsilon) ^ c = a^c + b c a^{c-1} \epsilon
 * \f]
 *
 * by the function derivative argument:
 * 
 * \f[
 * f(x) = x ^ c \\
 * f'(x) = c x ^ {c-1} \\
 * x = a + b \epsilon \\
 * f(a + b \epsilon) = f(a) + b f'(a) \epsilon \\
 *                   = a^c + b c a ^ {c-1} \epsilon \\
 * \f]
 */
template <typename Tp, typename _Up, unsigned Ne,
          internal::enable_if_t<internal::is_arithmetic<_Up>::value>* = nullptr>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
pow(const dual<Tp,Ne> & xx, const _Up & cc)
{
  DUAL_STD_MATH(pow);
  DUAL_STD_MATH(abs);
  DUAL_STD_MATH(exp);
#if 0
  dual<Tp,Ne> temp;
  Tp deriv, xval, tol;
  xval = xx.rpart();
  // TODO- should use numeric traits of Tp instead of 1e-15
  tol = Tp(1e-15);
  if (abs(xval) > 0 && abs(xval) < abs(tol)) {
    xval = xx.rpart() / (abs(xx.rpart()) / tol);
    //if (xval >= 0)
    //  xval = tol;
    //if (xval < 0)
    //  xval = -tol;
  }
  deriv = cc * pow(xval, (cc - Tp(1.0)));
  temp.rpart() = pow(xx.rpart(), cc);  //Use actual x value, only use tol for derivs
  temp.epart() = xx.epart() * deriv;
#endif
  dual<Tp,Ne> temp(pow(xx.rpart(), cc),
                 xx.epart() * Tp(cc) * Tp(pow(xx.rpart(), cc - _Up(1))));
  //temp.rpart() = pow(xx.rpart(), cc);
  //temp.epart() = xx.epart() * Tp(cc) * Tp(pow(xx.rpart(), cc - _Up(1)));
  return temp;
}

#if 1
/**
 * \f[
 * a ^ {c + d \epsilon} = a^c + d * a ^ c * \log(a) \epsilon
 * \f]
 *
 * by the function derivative argument:
 * 
 * \f[
 * f(y) = a ^ y \\
 * f'(y) = a ^ y \log (a) \\
 * y = c + d \epsilon \\
 * f(c + d \epsilon) = f(c) + d f'(c) \epsilon \\
 *                   = a^c + d a^c \log(a) \epsilon \\
 *
 * \f]
 */
template <typename Tp, typename _Up, unsigned Ne,
          internal::enable_if_t<internal::is_arithmetic<Tp>::value>* = nullptr>
DUAL_DEVICE_FUNC
dual<_Up,Ne>
pow(const Tp & aa, const dual<_Up,Ne> & yy)
{
  DUAL_STD_MATH(pow);
  DUAL_STD_MATH(log);
  dual<_Up,Ne> temp;
  temp.rpart() = pow(aa, yy.rpart());
  temp.epart() = yy.epart() * log(aa) * pow(aa, yy.rpart());
  return temp;
}

/**
 * \f[
 * (a + b \epsilon)^{(c + d \epsilon)} = a^c + (b c a^{c-1} + d \log(a) a^c)\epsilon
 * \f]
 *
 * by the function derivative argument:
 * 
 * \f[
 * f(x,y) = x ^ y \\
 * f'(x,y) = 
 * x = a + b \epsilon \\
 * y = c + d \epsilon \\
 * f(x,y) = \\
 *
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
pow(const dual<Tp,Ne> & xx, const dual<Tp,Ne> & yy)
{
  DUAL_STD_MATH(pow);
  DUAL_STD_MATH(log);
  dual<Tp,Ne> temp;
  temp.rpart() = pow(xx.rpart(), yy.rpart());
  temp.epart() =
    xx.epart() * yy.rpart() * pow(xx.rpart(), yy.rpart() - Tp(1)) +
    yy.epart() * log(xx.rpart()) * pow(xx.rpart(), yy.rpart());
  return temp;
}
#endif

/**
 * \f[
 * \exp(a + b \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
exp(const dual<Tp,Ne> & x)
{
  DUAL_STD_MATH(exp);
  return dual<Tp,Ne>(exp(x.rpart()),
                   exp(x.rpart()) * x.epart());
}

/**
 * \f[
 * \log(a + b \epsilon) =  
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
log(dual<Tp,Ne> x)
{
  DUAL_STD_MATH(log);
  Tp deriv1;
  deriv1 = x.epart() / x.rpart();
  return dual<Tp,Ne>(log(x.rpart()), deriv1);
}

/**
 * \f[
 * \sin(a + b \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
inline dual<Tp,Ne>
sin(dual<Tp,Ne> x)
{
  DUAL_STD_MATH(sin);
  DUAL_STD_MATH(cos);
  dual<Tp,Ne> temp;
  Tp funval, deriv;
  funval = sin(x.rpart());
  deriv = cos(x.rpart());
  temp.rpart() = funval;
  temp.epart() = deriv * x.epart();
  return temp;
}

/**
 * \f[
 * \cos(a + b \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
inline dual<Tp,Ne>
cos(dual<Tp,Ne> x)
{
  DUAL_STD_MATH(sin);
  DUAL_STD_MATH(cos);
  dual<Tp,Ne> temp;
  Tp funval, deriv;
  funval = cos(x.rpart());
  deriv = -sin(x.rpart());
  temp.rpart() = funval;
  temp.epart() = deriv * x.epart();
  return temp;
}

/**
 * \f[
 * \tan(a + b \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
inline dual<Tp,Ne>
tan(dual<Tp,Ne> x)
{
  DUAL_STD_MATH(tan);
  dual<Tp,Ne> temp;
  Tp funval, deriv;
  funval = tan(x.rpart());
  deriv  = funval*funval + 1.0;
  temp.rpart() = funval;
  temp.epart() = deriv*x.epart();
  return temp;
}

/**
 * \f[
 * \mathrm{asin}(a + b \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
asin(dual<Tp,Ne> x)
{
  DUAL_STD_MATH(asin);
  DUAL_STD_MATH(sqrt);
  dual<Tp,Ne> temp;
  Tp funval, deriv1, deriv;
  funval = asin(x.rpart());
  deriv1 = 1.0 - x.rpart()*x.rpart();
  deriv = 1.0 / sqrt(deriv1);
  temp.rpart() = funval;
  temp.epart() = deriv*x.epart();
  return temp;
}

/**
 * \f[
 * \mathrm{acos}(a + b \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
acos(dual<Tp,Ne> x)
{
  DUAL_STD_MATH(acos);
  DUAL_STD_MATH(sqrt);
  dual<Tp,Ne> temp;
  Tp funval, deriv1, deriv;
  funval = acos(x.rpart());
  deriv1 = 1.0 - x.rpart() * x.rpart();
  deriv = 1.0 / sqrt(deriv1);
  temp.rpart() = funval;
  temp.epart() = -deriv*x.epart();
  return temp;
}

/**
 * \f[
 * \mathrm{atan}(a + b \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
atan(dual<Tp,Ne> x)
{
  DUAL_STD_MATH(atan);
  dual<Tp,Ne> temp;
  Tp funval, deriv1, deriv;
  funval = atan(x.rpart());
  deriv1 = 1.0 + x.rpart() * x.rpart();
  deriv = 1.0 / deriv1;
  temp.rpart() = funval;
  temp.epart() = deriv * x.epart();
  return temp;
}

/**
 * \f[
 * \mathrm{atan2}(a + b \epsilon, c + d \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
atan2(dual<Tp,Ne> y, dual<Tp,Ne> x)
{
  DUAL_STD_MATH(atan2);
  dual<Tp,Ne> temp;
  Tp funval, deriv1, deriv;
  funval = atan2(y.rpart(), x.rpart());
  // unsure from here on...
  deriv1 = 1.0 + x.rpart() * x.rpart();
  deriv = 1.0 / deriv1;
  temp.rpart() = funval;
  temp.epart() = deriv * x.epart();
  return temp;
}

/**
 * \f[
 * \sqrt{a + b \epsilon} =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
sqrt(dual<Tp,Ne> x)
{
  DUAL_STD_MATH(pow);
  return pow(x, 0.5);
  //return pow(x, (typename dual<Tp,Ne>::scalar_type)0.5);
}

/**
 * \f[
 * \max(a + b \epsilon, c + d \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
max(dual<Tp,Ne> x1, dual<Tp,Ne> x2)
{
  return x1.rpart() >= x2.rpart() ? x1 : x2;
}

/**
 * \f[
 * \max(a + b \epsilon, c) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
max(dual<Tp,Ne> x1, Tp x2)
{
  return x1.rpart() >= x2 ? x1 : dual<Tp,Ne>(x2);
}

/**
 * \f[
 * \max(a, c + d \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
max(Tp x1, dual<Tp,Ne> x2)
{
  return x1 >= x2.rpart() ? dual<Tp,Ne>(x1) : x2;
}

/**
 * \f[
 * \min(a + b \epsilon, c + d \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
min(dual<Tp,Ne> x1, dual<Tp,Ne> x2)
{
  return x1.rpart() <= x2.rpart() ? x1 : x2;
}

/**
 * \f[
 * \min(a + b \epsilon, c) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
min(dual<Tp,Ne> x1, Tp x2)
{
  return x1.rpart() <= x2 ? x1 : dual<Tp,Ne>(x2);
}

/**
 * \f[
 * \min(a, c + d \epsilon) =
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
min(Tp x1, dual<Tp,Ne> x2)
{
  return x1 <= x2.rpart() ? dual<Tp,Ne>(x1) : x2;
}

#ifndef CXXDUALS_NO_COMPLEX
/**
 * Complex Conjugation
 * \f[
 * 
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<std::complex<Tp>,Ne>
conj(const dual<std::complex<Tp>,Ne> & x)
{
  // there is actually no derivative of conjugate()
  DUAL_STD_MATH(conj);
  dual<std::complex<Tp>,Ne> r (conj(x.rpart()));
  for (unsigned ii = 0; ii < Ne; ii++)
    r.epart(ii) = conj(x.epart(ii));
  return r;
}
#endif

/**
 * Dual Conjugation
 * \f[
 * i = \sqrt{-1} \\
 * \mathrm{real}( (e+f*i) + (g+h*i) \epsilon ) = e + g \epsilon
 * \f]
 *
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
dconj(const dual<Tp,Ne> & x)
{
  dual<std::complex<Tp>,Ne> r(x.rpart());
  for (unsigned ii = 0; ii < Ne; ii++)
    r.epart(ii) = -x.epart(ii);
  return r;
}

#ifndef CXXDUALS_NO_COMPLEX
/**
 * Coupled Conjugation
 * \f[
 * 
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<std::complex<Tp> >
cconj(const dual<std::complex<Tp> > & x)
{
  DUAL_STD_MATH(conj);
  dual<std::complex<Tp>,Ne> r (conj(x.rpart()));
  for (unsigned ii = 0; ii < Ne; ii++)
    r.epart(ii) = -conj(x.epart(ii));
  return r;
}

/**
 * Dual-Complex Conjugation
 * \f[
 * 
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<std::complex<Tp> >
dcconj(const dual<std::complex<Tp> > & x)
{
  DUAL_STD_MATH(conj);
  return conj(x.rpart()) * (1 - x.rpart() / x.epart());
}

/**
 * Anti-Dual Conjugation
 * \f[
 * adconj(
 * \f]
 *
 * Messelmi, Farid. “DUAL-COMPLEX NUMBERS AND THEIR HOLOMORPHIC FUNCTIONS,” n.d., 12.
 */
template <typename Tp>
DUAL_DEVICE_FUNC
dual<std::complex<Tp>,1>
adconj(const dual<std::complex<Tp>,1> & x)
{
  return dual<std::complex<Tp>,1>(x.epart(), -x.rpart());
}
#endif

/**
 * \f[
 * i = \sqrt{-1} \\
 * \mathrm{real}( (e+f*i) + (g+h*i) \epsilon ) = e + g \epsilon
 * \f]
 *
 */
template <typename Tp, unsigned Ne,
          internal::enable_if_t<is_complex<Tp>::value>* = nullptr>
DUAL_DEVICE_FUNC
dual<typename Tp::value_type>
real(const dual<Tp,Ne> & x)
{
  // todo - dont just make things up
  return dual<typename Tp::value_type>(real(x.rpart()),
                                       real(x.epart()));
}

/**
 * \f[
 * i = \sqrt{-1} \\
 * \mathrm{imag}( (e+f*i) + (g+h*i) \epsilon ) = f + h \epsilon
 * \f]
 *
 */
template <typename Tp, unsigned Ne,
          internal::enable_if_t<is_complex<Tp>::value>* = nullptr>
DUAL_DEVICE_FUNC
dual<typename Tp::value_type>
imag(const dual<Tp,Ne> & x)
{
  // todo - dont just make things up
  return dual<typename Tp::value_type>(imag(x.rpart()),
                                       imag(x.epart()));
}

/**
 * \f[
 * |a + b \epsilon| = 
 * \f]
 *
 * by the xfunction derivative argument: (for real-valued functions)
 * 
 * \f[
 * f(x) = \sqrt{(\mathrm{real}(x)^2 + \mathrm{imag}(x)^2)} \\
 * f'(x) = \frac{x}{|x|} f'(x) \\
 * x = a + b \epsilon \\
 * f(a + b \epsilon) = f(a) + b f'(a) \epsilon \\
 *
 * \f]
 *
 * and for complex-valued functions:
 * \f[
 * ?
 * \f]
 *
 */
template <typename Tp, unsigned Ne,
          typename Tpf = typename internal::nocx_filter<Tp>::test>
DUAL_DEVICE_FUNC
inline
dual<Tp,Ne>
abs(const dual<Tp,Ne> & x)
{
  DUAL_STD_MATH(abs);
  // according to ...
  return sqrt(dconj(x) * x);
  
  // how ceres does it
  // return abs(x.rpart()) == x.rpart() ? x : -x;

  // by way of arguing f' and
  // https://math.stackexchange.com/questions/1235365/find-the-derivative-of-absolute-value-using-the-chain-rule
  //return dual<Tp>(abs(x.rpart()),
  //                 (x.rpart() / abs(x.rpart())) * x.epart() * x.epart());
}

#ifndef CXXDUALS_NO_COMPLEX
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
inline
std::complex<Tp>
abs(const dual<std::complex<Tp> > & x)
{
  DUAL_STD_MATH(conj);
  // return abs(x.rpart()) == x.rpart() ? x : -x;
  return rpart(conj(x) * x);
  //return x.rpart();
  //return dual<typename dual<Tp>::scalar_type>(abs(x.rpart()),
  //                                             (x.rpart() / abs(x.rpart())) * x.epart() * x.epart());
}
#endif

/**
 * \f[
 * |a + b \epsilon|^2 = x
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
abs2(const dual<Tp,Ne> & x)
{
  return x * x;
}

/**
 * \f[
 * \mathrm{arg}(a + b \epsilon) = 
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
Tp
arg(const dual<Tp,Ne> & x)
{
  // x.rpart() != 0
  return x.epart() / x.rpart();
}

/**
 * \f[
 * \mathrm{norm}(a + b \epsilon) = | a + b \epsilon | = a
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
Tp
norm(const dual<Tp,Ne> & x)
{
  return x.rpart();
}


/**
 * \f[
 *      
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
ceil(const dual<Tp,Ne> & x)
{
  DUAL_STD_MATH(ceil);
  DUAL_STD_MATH(numeric_limits);
  Tp c = ceil(x.rpart());
  return dual<Tp,Ne>(c,
                   c == x.rpart() ?
                   numeric_limits<Tp>::infinity()
                   : Tp(0));
}

/**
 * \f[
 *      
 * \f]
 */
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
dual<Tp,Ne>
floor(const dual<Tp,Ne> & x)
{
  DUAL_STD_MATH(floor);
  DUAL_STD_MATH(numeric_limits);
  Tp f = floor(x.rpart());
  return dual<Tp,Ne>(f,
                   f == x.rpart()
                   ? numeric_limits<Tp>::infinity()
                   : Tp(0));
}

// fp classification
/// Are any of the parts NaN?
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
bool isnan(const dual<Tp,Ne> & x)
{
  DUAL_STD_MATH(isnan);
  bool isit = true;
  for (int ii = 0; isit && ii < dual<Tp,Ne>::num_elem; ii++)
    isit = isit && isnan(x.part(ii));
  return isit;
}

/// Are all of the parts not Inf?
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
bool isfinite(const dual<Tp,Ne> & x)
{
  DUAL_STD_MATH(isfinite);
  bool isit = true;
  for (int ii = 0; isit && ii < dual<Tp,Ne>::num_elem; ii++)
    isit = isit && isfinite(x.part(ii));
  return isit;
}

/// Are any of the parts Inf?
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
bool isinf(const dual<Tp,Ne> & x)
{
  DUAL_STD_MATH(isinf);
  bool isit = true;
  for (int ii = 0; isit && ii < dual<Tp,Ne>::num_elem; ii++)
    isit = isit && isinf(x.part(ii));
  return isit;
}

/// Are all of the parts isnormal()?
template <typename Tp, unsigned Ne>
DUAL_DEVICE_FUNC
bool isnormal(const dual<Tp,Ne> & x)
{
  DUAL_STD_MATH(isnormal);
  bool isit = true;
  for (int ii = 0; isit && ii < dual<Tp,Ne>::num_elem; ii++)
    isit = isit && isnormal(x.part(ii));
  return isit;
}

/// comparison
#define DUALH_COMPARISON_OP(OP)                                 \
  template <typename Tp, typename _Up, unsigned Ne,             \
            internal::enable_if_t<dual_traits<dual<Tp,Ne> >::depth == \
                                  dual_traits<dual<_Up,Ne> >::depth>* = nullptr> \
  DUAL_DEVICE_FUNC                                              \
  inline bool                                                   \
  operator OP (const dual<Tp,Ne> & lhs, const dual<_Up,Ne> & rhs) \
  {                                                             \
    return lhs.rpart() OP rhs.rpart();                                  \
  }                                                                     \
  template <typename Tp, typename _Up, unsigned Ne,                     \
            typename std::enable_if<internal::is_arithmetic<_Up>{},     \
                                    int>::type = 0>                     \
  DUAL_DEVICE_FUNC                                                  \
  inline bool                                                       \
  operator OP (const dual<Tp,Ne> & lhs, const _Up & rhs)            \
  {                                                                 \
    return lhs.rpart() OP rhs;                                          \
  }                                                                     \
  template <typename Tp, typename _Up, unsigned Ne,                     \
            typename std::enable_if<internal::is_arithmetic<_Up>{},     \
                                    int>::type = 0>                     \
  DUAL_DEVICE_FUNC                                              \
  inline bool                                                   \
  operator OP (const _Up & lhs, const dual<Tp,Ne> & rhs)        \
  {                                                             \
    return lhs OP rhs.rpart();                                  \
  }

DUALH_COMPARISON_OP(>)
DUALH_COMPARISON_OP(<)
DUALH_COMPARISON_OP(==)
DUALH_COMPARISON_OP(>=)
DUALH_COMPARISON_OP(<=)
DUALH_COMPARISON_OP(!=)

#undef DUALH_COMPARISON_OP
#if 0
// fix emacs auto formatting below this point for me
  ;
#endif
#undef DUAL_DEVICE_FUNC

//#include <iomanip>
template<typename Tp, unsigned Ne, typename _CharT, class _Traits>
std::basic_ostream<_CharT, _Traits> &
operator<<(std::basic_ostream<_CharT, _Traits> & os, const cxxduals::dual<Tp,Ne> & rhs)
{
  using namespace cxxduals;
#if 0
  // print nested duals
  std::basic_ostringstream<_CharT, _Traits> s;
  s.flags(os.flags());
  s.imbue(os.getloc());
  s.precision(os.precision());
  s << "(" << rhs.rpart()
    << " + e" << dual_traits<dual<Tp,Ne> >::depth << "*" << rhs.epart()
    << ")";
  return os << s.str();
#elif 1
  // print dual parts by epsilon-grade
  std::basic_ostringstream<_CharT, _Traits> s;
  s.flags(os.flags());
  s.imbue(os.getloc());
  s.precision(os.precision());
  s << "(";
  for (int p = 0; p < rhs.num_elem; p++) {
    if (p)
      s << " + e" << p << "*";
    s << rhs.part(p);
  }
  s << ")";
  return os << s.str();
#else
  // print as matrix (wrong)
  std::basic_ostringstream<_CharT, _Traits> s;
  s.flags(os.flags());
  s.imbue(os.getloc());
  s.precision(os.precision());
  s << "(";
  int side = rhs.num_elem;
  for (int i = 0; i < side; i++) {
    for (int j = 0; j < i; j++)
      //s << "         " << 0 << " ";
      s << std::setw(10) << 0 << " ";
    for (int j = i; j < side; j++) {
      s << std::setw(10) << rhs.part(j) << " ";
    }
    if (i < side-1)
      s << "\n ";
  }
  s << ")";
  return os << s.str();
#endif
}

} // namespace cxxduals

//////////////////////////////////////////////////////////////////////
// Eigen Support
//
#if defined(CXXDUALS_EIGEN) && !defined(EIGEN_VERSION_AT_LEAST)
#include <Eigen/Dense>
#endif
#ifndef EIGEN_VERSION_AT_LEAST
#define EIGEN_VERSION_AT_LEAST(...) 0
#define CXXDUALS_HACKY
#endif
#if defined(CXXDUALS_EIGEN) || EIGEN_VERSION_AT_LEAST(3, 3, 0)

namespace Eigen {

// This allows using cxxduals::dual in Eigen
template<typename _Scalar, unsigned Ne>
struct NumTraits<cxxduals::dual<_Scalar,Ne> > : GenericNumTraits<_Scalar>
{
  typedef cxxduals::dual<typename NumTraits<_Scalar>::Real,Ne> Real;
  //typedef cxxduals::dual<_Scalar> Real;
  //typedef _Scalar Real;
  typedef cxxduals::dual<typename NumTraits<_Scalar>::NonInteger,Ne> NonInteger;
  typedef cxxduals::dual<_Scalar,Ne> Nested;

  enum {
    IsInteger           =   NumTraits<_Scalar>::IsInteger,
    IsSigned            =   NumTraits<_Scalar>::IsSigned,
    IsComplex           =   0,
    //IsComplex           =   NumTraits<_Scalar>::IsComplex,
    RequireInitialization = NumTraits<_Scalar>::RequireInitialization,
    ReadCost            = 2 * NumTraits<_Scalar>::ReadCost,
    AddCost             = 2 * NumTraits<_Scalar>::AddCost,
    MulCost             = 4 * NumTraits<_Scalar>::MulCost + 2 * NumTraits<_Scalar>::AddCost
  };

  EIGEN_DEVICE_FUNC
  static inline Real epsilon()          { return Real(NumTraits<_Scalar>::epsilon()); }
  EIGEN_DEVICE_FUNC
  static inline Real dummy_precision()  { return Real(NumTraits<_Scalar>::dummy_precision()); }
};

template<typename Tp, typename BinaryOp>
struct ScalarBinaryOpTraits<Tp, cxxduals::dual<Tp>, BinaryOp > {
  typedef cxxduals::dual<Tp> ReturnType;
};

#ifndef CXXDUALS_NO_COMPLEX
template<typename Tp, typename BinaryOp>
struct ScalarBinaryOpTraits<Tp, cxxduals::dual<std::complex<Tp> >, BinaryOp > {
  typedef cxxduals::dual<std::complex<Tp> > ReturnType;
};
template<typename Tp, typename BinaryOp>
struct ScalarBinaryOpTraits<Tp, std::complex<cxxduals::dual<Tp> >, BinaryOp> {
  typedef std::complex<cxxduals::dual<Tp> > ReturnType;
};
template<typename Tp, typename BinaryOp>
struct ScalarBinaryOpTraits<std::complex<Tp>, std::complex<cxxduals::dual<Tp> >, BinaryOp > {
  typedef std::complex<cxxduals::dual<Tp> > ReturnType;
};
#endif

template<typename Tp, typename BinaryOp>
struct ScalarBinaryOpTraits<cxxduals::dual<Tp>, Tp, BinaryOp> {
  typedef cxxduals::dual<Tp> ReturnType;
};

#ifndef CXXDUALS_NO_COMPLEX
template<typename Tp, typename BinaryOp>
struct ScalarBinaryOpTraits<cxxduals::dual<std::complex<Tp> >, Tp, BinaryOp> {
  typedef cxxduals::dual<std::complex<Tp> > ReturnType;
};
template<typename Tp, typename BinaryOp>
struct ScalarBinaryOpTraits<std::complex<cxxduals::dual<Tp> >, Tp, BinaryOp> {
  typedef std::complex<cxxduals::dual<Tp> > ReturnType;
};
template<typename Tp, typename BinaryOp>
struct ScalarBinaryOpTraits<std::complex<cxxduals::dual<Tp> >, std::complex<Tp>, BinaryOp> {
  typedef std::complex<cxxduals::dual<Tp> > ReturnType;
};
#endif

} // namespace Eigen

namespace cxxduals {

/** define a custom template unary functor
 * use it like this: m2 = m1.unaryExpr(CwiseRpartOp<double>());
 */
template<typename Scalar>
struct CwiseRpartOp {
  const Scalar operator()(const Scalar & x) const { return x; }
  const Scalar operator()(const cxxduals::dual<Scalar> & x) const { return rpart(x); }
#ifndef CXXDUALS_NO_COMPLEX
  const std::complex<Scalar> operator()(const std::complex<Scalar> & x) const { return x; }
  const std::complex<Scalar> operator()(const std::complex<cxxduals::dual<Scalar> > & x) const {
    return std::complex<Scalar>(rpart(x.real()), rpart(x.imag()));
  }
#endif
};

/** define a custom template unary functor
 * use it like this: m2 = m1.unaryExpr(CwiseEpartOp<double>());
 */
template<typename Scalar>
struct CwiseEpartOp {
  const Scalar operator()(const cxxduals::dual<Scalar> & x) const { return epart(x); }
#ifndef CXXDUALS_NO_COMPLEX
  const std::complex<Scalar> operator()(const std::complex<Scalar> & x) const { return x; }
  const std::complex<Scalar> operator()(const std::complex<cxxduals::dual<Scalar> > & x) const {
    return std::complex<Scalar>(epart(x.real()), epart(x.imag()));
  }
#endif
};

}

#endif // CXXDUALS_EIGEN
#if defined(CXXDUALS_HACKY)
#undef CXXDUALS_HACKY
#undef EIGEN_VERSION_AT_LEAST
#endif

// End Eigen Support
//////////////////////////////////////////////////////////////////////

#ifndef CXXDUALS_NO_COMPLEX

namespace cxxduals {

/// Make working with std::complex<> nubmers suck less... allow promotion.
#define COMPLEX_OPS(OP)                                                 \
  template <typename Tp>                                               \
  std::complex<Tp>                                                     \
  operator OP(std::complex<Tp> lhs, const typename identity_t<Tp>::type & rhs) \
  {                                                                     \
    return lhs OP rhs;                                                  \
  }                                                                     \
                                                                        \
  template <typename Tp>                                               \
  std::complex<Tp>                                                     \
  operator OP(const typename identity_t<Tp>::type & lhs, const std::complex<Tp> & rhs) \
  {                                                                     \
    return lhs OP rhs;                                                  \
  }

COMPLEX_OPS(+)
COMPLEX_OPS(-)
COMPLEX_OPS(*)
COMPLEX_OPS(/)
#if 0
  ;
#endif

}

#endif // CXXDUALS_NO_COMPLEX

#endif // LIB_CXXDUALS
